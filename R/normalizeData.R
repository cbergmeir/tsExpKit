#' Data normalization.
#'
#' The input matrix is column-wise normalized. The parameter \code{type} specifies how:
#' \describe{
#' \item{0_1}{values are normalized to the [0,1]-interval. The minimum in the data is mapped to zero, the maximum to one.}
#' \item{center}{the data is centered, i.e. the mean is substracted}
#' \item{norm}{the data is normalized to mean zero, variance one}
#' }
#' 
#' @param x input data
#' @param type 
#' \describe{
#' \item{either}{type string specifying the type of normalization. Implemented are "0_1", "center", and "norm"}
#' \item{or}{attribute list of a former call to this method to apply e.g. normalization of the training data to the test data}
#' }
#' @return column-wise normalized input
#' @export
normalizeData <- function(x, type="norm") {
  
  if(!is.list(type))
    type <- computeNormalizationParameters(x, type)

  res <- normalizeDataWithParams(x, type, norm=TRUE) 
  
  res
}

#' Revert data normalization.
#'
#' Column-wise normalization of the input matrix is reverted.
#' 
#' @param x input data
#' @param normParams the parameters generated by an earlier call to \code{normalizeData} that will be used for reverting normalization
#' @return column-wise reverse-normalized input
#' @export
denormalizeData <- function(x, normParams)
  normalizeDataWithParams(x, normParams, norm=FALSE) 

# @export
computeNormalizationParameters <- function(x, type="norm") {
    
    x <- as.matrix(x)
    
    params <- list()
    
    if(type == "0_1") {
      
      colMaxima <- NULL
      colMinima <- NULL
      
      for(i in 1:ncol(x)) {
       
        colMaxima <- c(colMaxima, max(x[,i]))
        colMinima <- c(colMinima, min(x[,i]))
        
      }
      
      params$colMaxima <- colMaxima
      params$colMinima <- colMinima

    } else if(type== "center") {

      colMeans <- NULL
      
      for(i in 1:ncol(x)) {
        
        colMeans <- c(colMeans, mean(x[,i]))
        
      }
      
      params$colMeans <- colMeans
      
    } else {
      
      type="norm"

      colMeans <- NULL
      colSds <- NULL
            
      for(i in 1:ncol(x)) {

        colMeans <- c(colMeans, mean(x[,i]))
        colSds <- c(colSds, sd(x[,i]))
        
      }
      
      params$colMeans <- colMeans
      params$colSds <- colSds

    }
    
    params$type <- type
    params
}  

# @export
normalizeDataWithParams <- function(x, normParams, norm=TRUE) {
  
  x <- as.matrix(x)
  
  res <- NULL
  
  type <- normParams$type
  
  if(type == "0_1") {

    for(i in 1:ncol(x)) {
      
      colMax <- normParams$colMaxima[i]
      colMin <- normParams$colMinima[i]
      
      if(norm) {
        if((colMax - colMin) != 0)
          res <- cbind(res, (x[,i] - colMin) / (colMax - colMin))
        else 
          res <- cbind(res, (x[,i]))
      } else
        res <- cbind(res, x[,i] * (colMax - colMin) + colMin)
      
    }    
    
  } else if(type== "center") {
    
    for(i in 1:ncol(x)) {
      
      colMean <- normParams$colMeans[i]
      
      if(norm)
        res <- cbind(res, x[,i] - colMean)
      else  
        res <- cbind(res, x[,i] + colMean)
      
    }
    
  } else if(type== "norm") {
    
    for(i in 1:ncol(x)) {
      
      colMean <- normParams$colMeans[i]
      colSd <- normParams$colSds[i]
      
      if(norm) {
        if(colSd != 0)
          res <- cbind(res, (x[,i] - colMean) / colSd )
        else
          res <- cbind(res, (x[,i] - colMean))
      } else
        res <- cbind(res, x[,i] * colSd + colMean)
    }
    
  }
  
  attr(res, "normParams") <- normParams
  res
  
}
